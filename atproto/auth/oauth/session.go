package oauth

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"

	"github.com/bluesky-social/indigo/atproto/client"
	"github.com/bluesky-social/indigo/atproto/crypto"
	"github.com/bluesky-social/indigo/atproto/syntax"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/go-querystring/query"
)

type RefreshCallback = func(ctx context.Context, data ClientSessionData)

// Persisted information about an OAuth session. Used to resume an active session.
type ClientSessionData struct {
	// Account DID for this session. Assuming only one active session per account, this can be used as "primary key" for storing and retrieving this infromation.
	AccountDID syntax.DID `json:"account_did"`

	// Base URL of the "resource server" (eg, PDS). Should include scheme, hostname, port; no path or auth info.
	HostURL string `json:"host_url"`

	// Base URL of the "auth server" (eg, PDS or entryway). Should include scheme, hostname, port; no path or auth info.
	AuthServerURL string `json:"authserver_url"`

	// Full token endpoint
	AuthServerTokenEndpoint string `json:"authserver_token_endpoint"`

	// Token which can be used directly against host ("resource server", eg PDS)
	AccessToken string `json:"access_token"`

	// Token which can be sent to auth server (eg, PDS or entryway) to get a new access token
	RefreshToken string `json:"refresh_token"`

	// Current auth server DPoP nonce
	DpopAuthServerNonce string `json:"dpop_authserver_nonce"`

	// Current host ("resource server", eg PDS) DPoP nonce
	DpopHostNonce string `json:"dpop_host_nonce"`

	// The secret cryptographic key generated by the client for this specific OAuth session
	DpopPrivateKeyMultibase string `json:"dpop_privatekey_multibase"`

	// TODO: also persist access token creation time / expiration time? In context that token might not be an easily parsed JWT
}

type ClientSession struct {
	// HTTP client used for token refresh requests
	Client *http.Client

	Config         *ClientConfig
	Data           *ClientSessionData
	DpopPrivateKey crypto.PrivateKey

	RefreshCallback RefreshCallback

	// Lock which protects concurrent access to session data (eg, access and refresh tokens)
	lk sync.RWMutex
}

func (sess *ClientSession) RefreshTokens(ctx context.Context) error {

	// TODO: assuming confidential client
	clientAssertion, err := sess.Config.NewClientAssertion(sess.Data.AuthServerURL)
	if err != nil {
		return err
	}

	body := RefreshTokenRequest{
		ClientID:            sess.Config.ClientID,
		GrantType:           "authorization_code",
		RefreshToken:        sess.Data.RefreshToken,
		ClientAssertionType: &CLIENT_ASSERTION_JWT_BEARER,
		ClientAssertion:     &clientAssertion,
	}

	vals, err := query.Values(body)
	if err != nil {
		return err
	}
	bodyBytes := []byte(vals.Encode())

	// XXX: persist this back to the data?
	dpopServerNonce := sess.Data.DpopAuthServerNonce
	tokenURL := sess.Data.AuthServerTokenEndpoint

	var resp *http.Response
	for range 2 {
		dpopJWT, err := NewAuthDPoP("POST", tokenURL, dpopServerNonce, sess.DpopPrivateKey)
		if err != nil {
			return err
		}

		req, err := http.NewRequestWithContext(ctx, "POST", tokenURL, bytes.NewBuffer(bodyBytes))
		if err != nil {
			return err
		}
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		req.Header.Set("DPoP", dpopJWT)

		resp, err = sess.Client.Do(req)
		if err != nil {
			return err
		}

		// check if a nonce was provided
		dpopServerNonce = resp.Header.Get("DPoP-Nonce")
		if resp.StatusCode == 400 && dpopServerNonce != "" {
			// TODO: also check that body is JSON with an 'error' string field value of 'use_dpop_nonce'
			var errResp map[string]any
			if err := json.NewDecoder(resp.Body).Decode(&errResp); err != nil {
				slog.Warn("initial token request failed", "authServer", tokenURL, "err", err, "statusCode", resp.StatusCode)
			} else {
				slog.Warn("initial token request failed", "authServer", tokenURL, "resp", errResp, "statusCode", resp.StatusCode)
			}

			// loop around try again
			resp.Body.Close()
			continue
		}
		// otherwise process result
		break
	}

	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		var errResp map[string]any
		if err := json.NewDecoder(resp.Body).Decode(&errResp); err != nil {
			slog.Warn("initial token request failed", "authServer", tokenURL, "err", err, "statusCode", resp.StatusCode)
		} else {
			slog.Warn("initial token request failed", "authServer", tokenURL, "resp", errResp, "statusCode", resp.StatusCode)
		}
		return fmt.Errorf("initial token request failed: HTTP %d", resp.StatusCode)
	}

	var tokenResp TokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return fmt.Errorf("token response failed to decode: %w", err)
	}
	// XXX: more validation of response?

	sess.Data.AccessToken = tokenResp.AccessToken
	sess.Data.RefreshToken = tokenResp.RefreshToken

	return nil
}

func (sess *ClientSession) NewAccessDPoP(method, reqURL string) (string, error) {

	ath := S256CodeChallenge(sess.Data.AccessToken)
	claims := dpopClaims{
		HTTPMethod:      method,
		TargetURI:       reqURL,
		AccessTokenHash: &ath,
		RegisteredClaims: jwt.RegisteredClaims{
			Issuer:    sess.Data.AuthServerURL,
			ID:        randomNonce(),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(JWT_EXPIRATION_DURATION)),
		},
	}
	if sess.Data.DpopHostNonce != "" {
		claims.Nonce = &sess.Data.DpopHostNonce
	}

	keyMethod, err := keySigningMethod(sess.DpopPrivateKey)
	if err != nil {
		return "", err
	}

	// TODO: store a copy of this JWK on the ClientSession as a private field, for efficiency
	pub, err := sess.DpopPrivateKey.PublicKey()
	if err != nil {
		return "", err
	}
	pubJWK, err := pub.JWK()
	if err != nil {
		return "", err
	}

	token := jwt.NewWithClaims(keyMethod, claims)
	token.Header["typ"] = "dpop+jwt"
	token.Header["jwk"] = pubJWK
	return token.SignedString(sess.DpopPrivateKey)
}

// copy a request URL and strip query params and fragment, for DPoP
func dpopURL(u *url.URL) string {
	u2 := *u
	u2.RawQuery = ""
	u2.ForceQuery = false
	u2.Fragment = ""
	u2.RawFragment = ""
	return u2.String()
}

func (sess *ClientSession) DoWithAuth(c *http.Client, req *http.Request, endpoint syntax.NSID) (*http.Response, error) {

	durl := dpopURL(req.URL)

	// XXX: fetch with mutex lock
	accessToken := sess.Data.AccessToken
	originalNonce := sess.Data.DpopHostNonce
	dpopNonce := originalNonce

	var resp *http.Response
	for range 3 {
		dpopJWT, err := sess.NewAccessDPoP(req.Method, durl)
		if err != nil {
			return nil, err
		}
		req.Header.Set("Authorization", fmt.Sprintf("DPoP %s", accessToken))
		req.Header.Set("DPoP", dpopJWT)

		resp, err = c.Do(req)
		if err != nil {
			return nil, err
		}

		// on success, or most errors, just return HTTP response
		if resp.StatusCode != http.StatusBadRequest || !strings.HasPrefix(resp.Header.Get("Content-Type"), "application/json") {
			return resp, nil
		}

		// parse the error response body (JSON) and check the error name
		defer resp.Body.Close()
		var eb client.ErrorBody
		if err := json.NewDecoder(resp.Body).Decode(&eb); err != nil {
			return nil, &client.APIError{StatusCode: resp.StatusCode}
		}

		// if DPoP nonce was stale, simply retry
		if eb.Name == "use_dpop_nonce" && resp.Header.Get("DPoP-Nonce") != "" {
			dpopNonce = resp.Header.Get("DPoP-Nonce")
			if dpopNonce != originalNonce {
				// XXX: persist new nonce value via callback
			}

			retry := req.Clone(req.Context())
			if req.GetBody != nil {
				retry.Body, err = req.GetBody()
				if err != nil {
					return nil, fmt.Errorf("API request retry GetBody failed: %w", err)
				}
			}
			req = retry
			continue
		}

		// if this is anything other than an expired token, bail out now
		if eb.Name != "ExpiredToken" {
			return nil, eb.APIError(resp.StatusCode)
		}

		if err := sess.RefreshTokens(req.Context()); err != nil {
			return nil, err
		}

		// XXX: fetch with mutex lock
		accessToken = sess.Data.AccessToken

		retry := req.Clone(req.Context())
		if req.GetBody != nil {
			retry.Body, err = req.GetBody()
			if err != nil {
				return nil, fmt.Errorf("API request retry GetBody failed: %w", err)
			}
		}
		req = retry
		continue
	}

	return nil, fmt.Errorf("OAuth client ran out of retries")
}

func (sess *ClientSession) APIClient() *client.APIClient {
	c := client.APIClient{
		Client:     sess.Client,
		Host:       sess.Data.HostURL,
		Auth:       sess,
		AccountDID: &sess.Data.AccountDID,
	}
	if sess.Config.UserAgent != "" {
		c.Headers.Set("User-Agent", sess.Config.UserAgent)
	}
	return &c
}
